<!--
 * @Author: Loren
 * @Date: 2022-04-11 20:03:53
 * @LastEditTime: 2022-04-12 00:45:57
 * @FilePath: /c_plus_plus_book/gitbook/Chapter1.md
 * @Description: Chapter1 description.
 * 
 * Copyright (c) 2022 by Loren, All Rights Reserved. 
-->
# 第一章 变量和基本类型

## 数据类型

数据类型是程序的基础，它告诉我们**数据的意义**以及我们能在**数据上执行的操作**。

### 基本内置类型
C++中定义了一套包含 **算术类型(arithmetic type)**和**空类型(void)** 在内的基本数据类型。其中算术类型包含了
**字符(char)、整数形(int)、布尔值(bool)和浮点数(double、float)**。空类型不对应具体的值，经常用于函数的返回值。

C++算术类型如下表

|       类型       |      含义      |   最小尺寸   |
| :--------------: | :------------: | :----------: |
|       bool       |    布尔类型    |    未定义    |
|       char       |      字符      |     8位      |
|     wchar_t      |     宽字符     |     16位     |
|     char16_t     |  Unicode字符   |     16位     |
|     char32_t     |  Unicode字符   |     32位     |
|      short       |     短整形     |     16位     |
|       int        |      整形      |     16位     |
|       long       |     长整形     |     32位     |
| long long(C++11) |     长整形     |     64位     |
|      float       |  单精度浮点数  | 6位有效数字  |
|      double      |  双精度浮点数  | 10位有效数字 |
|   long double    | 扩展精度浮点数 | 10位有效数字 |

对于整形来说,即 `short、int、long、long long` 可以分为**带符号(signed)--表示正数、负数、0**和**不带符号(unsigned)--仅仅表示大于0的值**两种。整形都是**带符号的**。在整形前面使用关键字 `unsigned` 就变成了无符号类型。例如 `unsigned int`。

对于字符型来说，字符型 `char` 被分为了三种： `char` 、 `signed char`、 `unsigned char`。注意：`char` 和 `signed char` **不是**同一种类型。虽然字符有三种类型，但是表现形式只有两种：带符号和不带符号，
至于 `char` 会表现为那种形式，具体有编译器决定。

### 值
值在C++中是一个**纯粹的数学抽象概念**。在程序中作为一种**只读数据**存在。

#### 字面值常量(literal)
顾名思义，字面值常量就是值一见便知。字面值常量的形式和值决定了它的数据类型。
字面值常量又分为整形和浮点型字面值、字符和字符串字面值、转义序列、布尔字面值和指针字面值。

##### 整形和浮点型字面值
整形字面值的具体数据类型由它的**值**和**符号**决定。默认情况下，十进制字面值是**带符号数**。尽管整形字面值存储在带符号数据类型中，但严格来说，**十进制字面值不会是负数**，例如：当我们使用一个形如 `-42` 的负十进制字面值，那个**负号并不在字面值**之内，它的作用仅仅是对字面值取负而已。

浮点数字面值表现为一个**小数**或**科学计数法**表示的指数。例如：`3.14159`或`4e-10`。

#### 字符和字符串字面值
由**单引号**括起来的一个字符称为`char`型字面值；由**双引号**括起来的零个或多个字符则构成字符串型字面值。例如：
```C++
'a' // 字符字面值
"F U C++!"  // 字符串字面值 
```
字符串字面值的类型其实是由常量字符构成的数组(array)，(见TODD)。编译器将会在**每个字符串的结尾处添加一个空字符(`'\0'`)**，因此字符串字面值的实际长度要比内容**多1**。

#### 转义序列
有两类字符程序员不能使用，一类是**不可打印(nonprintable)**，例如退格(删除)和其他控制字符(上下左右)。另一类是在C++中有特殊含义的字符，这个时候就需要**转义序列**。转义序列均以反斜杠`\`开始。C++规定的转义序列如下表：

| 转义序列 |    含义    |
| :------: | :--------: |
|    \n    |    换行    |
|    \t    | 横向制表符 |
|    \a    |   宽字符   |
|    \v    | 纵向制表符 |
|    \b    |   退格符   |
|    \\"    |   双引号   |
|    \\'    |   单引号   |
|    \\    |   反斜线   |
|    \r    |   回车符   |
|    \f    |   进纸符   |

#### 布尔字面值和指针字面值
布尔字面值为 `true` 和 `false`。
指针字面值(见TODO)

## 变量
变量(variable)，在C++中指的**是一块内存空间**，是与计算机内存这个物理设备关联在一起的。(故，需要**区分数学上抽象的变量**的概念)。在本笔记中，变量(以及后面的对象)均指**具有某种数据类型的内存空间**。

### 初始化
在定义(创建)一个变量(或对象)的时候，获得了一个特定的值，我们就说这个变量(或对象)被 **初始化(initialized)** 了。例如：
```C++
int x = 10; // 初始化整形变量x的值为10.
```

在C++中，初始化和赋值是两个完全不同的操作。二者在概念上**严格区分**。
**初始化**：在定义(创建)变量(对象)的时候赋予其一个初值
**赋值**：把变量(对象)的当前值擦除，用一个新的值来代替
例如：
```C++
int x = 10; // 初始化整形变量x的值为10.
x = 20;     // 赋值，将x的当前值10擦除，用一个新值20代替.
```
以上概念需要严格区分！！


C++中定义初始化的好几种不同形式。

#### 列表初始化
以下4中方式均能初始化整形变量x，而初始化列表是C++11引入的新标准，即用**花括号去初始化变量**。

```C++
int x = 0;
int x = {0};  // 列表初始化
int x{0};     // 列表初始化
int x(0);
```
关于列表初始化(list initialization)，在类以及后面的`vwctor`内容均会看到。这里只做一个说明。
需要说明的是，在使用列表初始化的时候，且存在 **初始值丢失的风险(类型转换)** 的时候，编译器将会报错，例如：
```C++
long double pi = 3.1415926536;
int a{pi}, b = {pi}; // 错误，转换未执行，存在丢失信息的危险.
int c(ld), d = ld;   // 正确，转换执行，且确实丢失了部分值.
```

#### 默认初始化
所谓默认初始化(default initialized)，指的是定义(创建)变量(或对象)的时候，**没有指定初始值**，则变量就会被默认初始化。
对于内置类型的变量没有被显式初始化，它的值由定义(创建)它的位置决定。如果在任何函数之外的变量将会被初始化0。在函数体内部的内置类型将不被初始化。如果试图拷贝或者以其他形式访问，将会报错。
每个类各自决定其初始化对象的方式。而且，是否不经初始化就定义对象也由类自己决定。

总结：
1. 定义于函数体内部的**内置类型**的对象(或变量)没有初始化，则其值未定义。
2. 类的对象如果没有显式初始化，则其值由类确定。

**使用未被初始化的变量将会带来无法预计的后果！！！！**

### 变量声明和定义的关系
为了允许把程序拆分成多个逻辑部分来编写，C++支持**分离式编译(separate compilation)**，该机制允许将程序分割为若干个文件，每个文件可以被独立编译。
为了支持这种机制，C++将声明和定义区分开来。声明(declaration)使得名字为程序所知道，如果A文件想要使用B文件中的变量，则必须包含对那个名字的声明。而定义(declaration)则定义(创建)与名字相关联的实体，即内存空间。
定义和初始化的区别在于：初始化会为变量赋予一个初值。
**要想声明一个变量而非定义它，在变量名前面添加关键字`extern`，且不要显示初始化。**
例如：
```C++
extern int x; // 声明整形变量x而并非定义x.
int y;        // 定义整形变量y. 
int z = 0;    // 初始化整形变量z为0.
z = 10;       // 赋值.
extern double pi = 3.14159; //定义，抵消 extern 的作用
```
如果在函数体内部试图初始化一个由 `extern`关键字标记的变量，将会引发错误。

## 标识符
C++的标识符(identifier)，说白了就是变量、函数、类等的名称。这里参考 [谷歌开源代码风格之命名规范](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/naming/)

标识符或者说命名，**一定要规范！！！！**。

## 作用域
在C++程序中，无论是在程序的什么位置，使用到的每一个名字(标识符)都会指向一个特定的实体：变量、函数、类型等。然而，**同一个名字出现在不同的位置，也可能指向的是不同的实体**。

### 名字的作用域
名字(标识符)的作用域(scope)是程序的一部分，在作用域内的名字有其特定的含义，C++中大多数作用域均用**花括号**分割。

#### 全局作用域
全局作用域(global scope)，位于其他所有作用域之外的作用域。全局作用域天然存在于C++程序中，它不需要由程序员人为地定义。


#### 块作用域
块作用域(block scope)，又称局部作用域(local scope)。

关于全局变量和局部变量以及变量的生存周期，见(TODO)。

### 嵌套的作用域
作用域能包含彼此，**被包含(被嵌套)的作用域称为内层作用域(inner scope)**，**包含别的作用域的作用域称为外层作用域(outer scope)**。

在作用域中声明某个名字， **它所嵌套着的所有作用域中都能访问**。同时也允许 **在内层作用域中重新定义外层作用域已有的名字**。例如：`code/chapter1/demo1.cpp`
```C++
/* 该程序仅仅做说明
 * 同时需要注意：函数内部不宜定义与全局变量相同的新变量
 */
#include <iostream>

int reused = 42;  // 全局变量
int main() {
  int unique = 0;  // 变量 unique 具有块作用域

  // 第一次输出：全局变量和局部变量
  std::cout << reused << " " << unique << std::endl;

  // 定义并初始化一个新的局部变量，该变量与全局变量同名，将会覆盖(隐藏)全局变量
  int reused = 0;  // 局部变量 reused 具有块作用域

  // 第二次输出：两个局部变量
  std::cout << reused << " " << unique << std::endl;

  // 第三次输出：显示访问全局变量
  std::cout << ::reused << " " << unique << std::endl;

  return 0;
}
```
上述代码中，第24行的语句 `int reused = 0`，隐藏了外层作用域中的 `reused` 变量，因此将会输出 `0`。此时如果想要访问外层作用域中的 `reused` 变量，需要加上 **域操作符  `::reused`**。

需要说明的是：如果函数有可能用到全局变量，则不应该再定义一个同名的局部变量，因为 **会覆盖(隐藏)外层作用域同名变量**。因此在定义全局的变量的时候，根据谷歌命名规范，通常在变量名前面添加一个前缀 `g` ，即 `g_reused` 表示变量 `g_reused` 是一个全局变量。