<!--
 * @Author: Loren
 * @Date: 2022-04-22 15:35:34
 * @LastEditTime: 2022-04-22 16:28:40
 * @FilePath: /c_plus_plus_book/gitbook/concurrency_1.md
 * @Description: 
 * 
 * Copyright (c) 2022 by Loren, All Rights Reserved. 
-->
# C++ 并发简介

## 什么叫做并发
最简单和最基本的并发,是指 **两个或更多独立的活动同时发生**。例如一边走路一边听歌一边说话等。

### 计算机中的并发
计算机领域的并发指的是 **在单个系统里同时执行多个独立的任务** ，而非顺序的进行一些活动。

计算机初期的并发：计算机只有一个处理器的时候，**只能在某一时刻执行一个任务，不过它可以每秒进行多次任务切换** ，让任务看起来是并发执行的。这种方式称为 **任务切换(task switching)** 。

计算机现在：计算机有多个处理器的时候，能够真正执行并发多个任务。这种方式称为 **硬件并发(hardware concurrency)** 

下图展示了并发的两种方式

<center>并发的两种方式</center>

可以看到，进行任务切换的时候，系统需要切换一次 **上下文** ，图中灰色分割的部分，任务切换也有时间开销。进行上下文切换的时候，操作系统必须为当前运行的任务 **保存CPU的状态和指令指针**，并计算出要切换到哪一个任务等。

### 并发的途径和方式
并发的途径分为：

第一种途径是 **有多个单线程的进程**
第二种途径是 **单一进程里面有多个线程**

并发的方式分为：
第一种方式是 **多进程并发**
第二种方式是 **多线程并发**

下面将分别介绍

#### 多进程并发
第一种途径就是使用 **多个单线程的进程**。将应用程序分为多个独立的进程，它们在同一时刻运行，就像同时进行网页浏览和文字处理一样。如下图所示


#### 多线程并发
第二种途径就是使用 **单一进程里面有多个线程** 。 **每个线程相互独立运行** ，且线程可以在不同的指令序列中运行。但是，同一个进程中的所有线程都 **共享地址空间** ，并且所有线程访问到大部分数据———全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。图下图所示

### 为什么使用并发
主要是两点： 关注点分离(SOC)和性能

#### 关注分离(SOC)
通过将相关的代码与无关的代码分离，可以使程序更
容易理解和测试，从而减少出错的可能性。即使一些功能区域中的操作需要在同一时刻发生的情况下，依旧可以使用并发分离不同的功能区域；若不显式地使用并发，就得编写一个任务切换框架，或者在操作中主动地调用一段不相关的代码。

#### 性能
如果想要利用日益增长的计算能力，那就必须设计多任务并发式软件。

两种利用并发提高性能：
1. 将一个单个任务分成几部分，且各自并行运行，从而降
低总运行时间。这就是 **任务并行(task parallelism)**。
任务并行过程中存在两个依赖：
- 过程方面

一个线程执行算法的一部分，另一线程执行算法的另一部分
- 数据方面

每个线程在 **不同的数据** 部分上 **执行相同的操作**

2. 使用可并行的方式。(TODO)

### 什么时候不使用并发
基本上，不使用并发的唯一原因就是， **收益比不上成本**。

如果让太多的线程同时运行，则会消耗很多操作系统资源，从而使得操作系统整体上运行得更加缓慢。

### C++中使用的并发和多线程

#### 入门
一个C++多线程程序是什么样子呢?其实，它看上去和其他C++程序差不多，通常是变量、类以及函数的组合。唯一的区别在于 **某些函数可以并发运行**。为了并发地运行函数，必须使用 **特定的函数以及对象来管理各个线程**。

下面这个程序是所有C++入门的程序
```C++
#include <iostream>
int main()
{
std::cout << "Hello World\n";
}
```

如果采用一个线程来运行，将会是这样的。`c_plus_plus_book/code/concurrency/demo1.cpp`
```C++
#include <iostream>
#include <thread> //①
void hello() //②
{
std::cout << "Hello Concurrent World\n";
}
int main()
{
std::thread t(hello); //③
t.join(); //④
}
```

首先增加了C++库中的对多线程支持的头文件`thread`

其次输出信息被移动到了一个独立的函数中。因为 **每个线程都必须具有一个初始函数(initial function)**。新的线程将从这里开始执行。对于该代码来说 `main()` 初始线程或者叫主线程。

```text
从这里可以知道，多线程的对象是一个函数。
```

接着，通过 **std::thread** 创建一个线程对象。

最后，调用 `join()` 的原因见后面的笔记